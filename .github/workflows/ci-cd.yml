name: CI/CD Pipeline

on:
  push:
    branches: [ main ]  # Executa ao fazer push para main
  pull_request:
    branches: [ main ]  # Executa ao abrir PR para main

# Define as permissões necessárias
permissions:
  contents: read
  packages: write

jobs:
  # 1º -> Job de Build e Testes
  build-and-test:
    name: Build e Testes
    runs-on: ubuntu-latest

    steps:
      # Passo 1: Fazer checkout do código
      - name: Checkout do código
        uses: actions/checkout@v4

      # Passo 2: Configurar Node.js
      - name: Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'
          cache-dependency-path: package-lock.json

      # Passo 3: Instalar dependências
      - name: Instalar dependências
        run: npm install

      # Passo 4: Executar testes unitários
      - name: Executar testes
        run: npm run test -- --watch=false --browsers=ChromeHeadless

      # Passo 5: Build de produção
      - name: Build da aplicação
        run: npm run build -- --configuration production

      # Passo 6: Upload dos artefatos de build, mantendo por 7 dias após o build
      - name: Upload do build - projeto ana.cagliari
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: dist/projeto-devops/
          retention-days: 7

  # 2º -> Job de análise de qualidade de código
  code-quality:
    name: Análise de Qualidade
    runs-on: ubuntu-latest

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'
          cache-dependency-path: package-lock.json

      - name: Instalar dependências
        run: npm install

      # Análise de segurança nas dependências
      - name: Auditoria de segurança
        run: npm audit --audit-level=critical # falha apenas em vulnerabilidades críticas

      # Verifica se não há dependências desatualizadas críticas
      - name: Verificar dependências desatualizadas
        run: npm outdated || true # não falha o pipeline, apenas informa

  # 3º -> Job de Build Docker
  docker-build:
    name: Build e Push Docker
    needs: [build-and-test, code-quality]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extrair metadados
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/devops-pucrs-ana-cagliari
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build e Push da imagem
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # 4º -> Job de Provisionamento com Terraform
  terraform:
    name: Provisionar Infraestrutura
    needs: build-and-test
    runs-on: ubuntu-latest
    # Só executa terraform no push para main
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    outputs:
      instance_ip: ${{ steps.terraform-output.outputs.ip }}

    steps:
    - name: Checkout do código
      uses: actions/checkout@v4

    # Configura credenciais AWS
    - name: Configurar credenciais AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: us-east-1

    # Setup Terraform
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false

    # Inicializa Terraform
    - name: Terraform Init
      run: |
        cd infra/terraform
        terraform init

    # Valida configuração do Terraform
    - name: Terraform Validate
      run: |
        cd infra/terraform
        terraform validate

    # Aplica Terraform
    - name: Terraform Apply
      run: |
        cd infra/terraform
        terraform apply -auto-approve \
          -var="key_name=${{ secrets.AWS_KEY_NAME }}"

    #  Captura o IP da instância
    - name: Obter IP da instância
      id: terraform-output
      run: |
        cd infra/terraform
        INSTANCE_IP=$(terraform output -raw instance_public_ip)
        echo "ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
        echo "IP da instância: $INSTANCE_IP"

# 5º -> Job de Deploy (CD)
  deploy:
    name: Deploy para EC2
    needs: terraform
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Configurar SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AWS_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.terraform.outputs.instance_ip }} >> ~/.ssh/known_hosts

      - name: Aguardar instância estar pronta
        run: |
          echo "Aguardando instância EC2 estar pronta..."
          sleep 60

      - name: Instalar Docker na EC2
        run: |
          ssh -i ~/.ssh/id_rsa ec2-user@${{ needs.terraform.outputs.instance_ip }} << 'EOF'
            # Atualiza o sistema
            sudo yum update -y

            # Instala Docker
            sudo yum install docker -y

            # Inicia o Docker
            sudo systemctl start docker
            sudo systemctl enable docker

            # Adiciona o usuário ao grupo docker
            sudo usermod -aG docker ec2-user
          EOF

      - name: Deploy da aplicação
        run: |
          ssh -i ~/.ssh/id_rsa ec2-user@${{ needs.terraform.outputs.instance_ip }} << 'EOF'
            # Para e remove containers antigos
            sudo docker stop devops-app 2>/dev/null || true
            sudo docker rm devops-app 2>/dev/null || true

            # Remove imagens antigas
            sudo docker image prune -af

            # Faz pull da nova imagem
            sudo docker pull ${{ secrets.DOCKER_USERNAME }}/devops-pucrs-ana-cagliari:latest

            # Executa o container
            sudo docker run -d \
              --name devops-app \
              --restart unless-stopped \
              -p 80:80 \
              ${{ secrets.DOCKER_USERNAME }}/devops-pucrs-ana-cagliari:latest

            # Verifica o status
            sudo docker ps
          EOF

      - name: Verificar saúde da aplicação
        run: |
          echo "Verificando aplicação em http://${{ needs.terraform.outputs.instance_ip }}"
          sleep 10
          curl -f http://${{ needs.terraform.outputs.instance_ip }} || exit 1

  # 6º -> Job de notificação de sucesso
  notify-success:
    name: Notificar Sucesso
    runs-on: ubuntu-latest
    needs: [build-and-test, code-quality, docker-build, terraform, deploy]
    if: success()

    steps:
      # Mensagem de sucesso
      - name: Pipeline concluído com sucesso
        run: |
          echo "Pipeline CI/CD executado com sucesso!"
          echo "Build gerado e testado"
          echo "Análise de segurança concluída"
          echo "Imagem Docker criada e publicada"
          echo "Infraestrutura provisionada"
          echo "Deploy realizado com sucesso"
          echo "Aplicação disponível em: http://${{ needs.terraform.outputs.instance_ip }}"
